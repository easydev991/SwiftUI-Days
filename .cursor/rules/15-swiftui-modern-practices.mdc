---
description: Современные практики SwiftUI — состояние, async/await, композиция, без ViewModel-абстракций
globs:
  - "**/*.swift"
alwaysApply: false
---
## Современные практики SwiftUI

- Используйте нативный поток данных SwiftUI:
  - `@State` — локальное состояние экрана/вью
  - `@Binding` — двусторонний поток данных между родителем и дочкой
  - `@Observable` — разделяемое состояние в сервисах
  - `@Environment` — DI для общих сервисов и ключей окружения

- Не вводим обязательных ViewModel-слоёв. Если структура совпадает с MVVM — это совпадение, а не правило.

- Владение состоянием: держите состояние как можно ближе к месту использования. Выносите в общие сервисы только то, что реально используется в нескольких местах.

- Предпочитайте `async/await` и модификатор `.task` для жизненно-цикловых операций; обрабатывайте ошибки через `do/try/catch`.

- Композиция UI: небольшие и сфокусированные вью, вынос переиспользуемого в `Screens/CommonViews` и поддеревья экранов.

- Не вкладывайте `@Observable` объекты друг в друга (избегайте наблюдаемых полей, содержащих другие наблюдаемые объекты), чтобы не ломать систему наблюдения SwiftUI. Инициализируйте и прокидывайте зависимости на уровне вью через `Environment`.

### Примеры из проекта

- Локальное состояние экрана:
@SwiftUI-Days/Screens/Detail/ItemScreen.swift

- Доступ к общему сервису настроек через `Environment` и реактивное обновление темы:
@SwiftUI-Days/SwiftUI_DaysApp.swift
@SwiftUI-Days/Screens/More/ThemeIcon/ThemeIconScreen.swift
